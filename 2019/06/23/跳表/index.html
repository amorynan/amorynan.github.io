<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>跳表一二事 | WelCome to amory's world!</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="icon" href="/favicon.ico"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#跳表一二事"><span class="toc-number">1.</span> <span class="toc-text">跳表一二事</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1561376322195&amp;di=968ecdc60b194dac7a024a8e75182703&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F94o3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F91529822720e0cf397cc85d40846f21fbe09aae2.jpg"></div><div class="author-info__name text-center">amory wang</div><div class="author-info__description text-center">hey ...</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">18</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">WelCome to amory's world!</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">跳表一二事</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-23 </time></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><hr>
<h2 id="跳表一二事"><a href="#跳表一二事" class="headerlink" title="跳表一二事"></a>跳表一二事</h2><p>呃，开启这篇之前先吐槽一下简书。。。我记得我专门写过一片跳表的文章的，结果不见了，不见了，见了，了。然后就怀疑人生，算了生活还是要继续，文章还是要记录，学习的👣不能因为这多大点儿事就停下来吧， 迁移到git管理了</p>
<p>跳表其实就是基于链表+索引的数据结构,首先链表为地基，但是链表大家都知道是没有办法支持很好的查找，一般都是o(n) 的时间，而大家常说的删除和插入友好也是在特定的知道指针指向的情况下，所以要保证一个有序的链表的插入和删除的时间复杂度o（n）是需要的，其次从硬件资源的角度分析，链表不支持二八原则带来的优势，可以局部性获取数据到cpu 缓存，那么有什么可以让链表的查询也变得比较高效呢？答案就是那就给他加个索引吧</p>
<p>其实我觉得索引真正的含义就是能在一堆有规律的数据中找到规律的数据建立索引值然后查找相应的数据，想法是美好的，问题就在于难在不知道如何建立索引值，以什么样的方式建立怎样的索引，那么跳表就是大神想到的可以比较好的为链表建立索引支持o（logn）的查询时间复杂度，当然时间复杂度的下降肯定会有空间复杂度的上升的守恒定律还是会遵守的，大概介绍了之后，就来真正看一下跳表的实现</p>
<p>首先跳表的基础还是链表，所以链表有的节点，当然跳表也是会有的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class SkipNode&lt;E extends Comparable&lt;? super E&gt;&gt; &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 节点存储的值Val</span><br><span class="line">         */</span><br><span class="line">        E val;</span><br><span class="line">        /*</span><br><span class="line">         * 节点指向第i层的节点next[i], 这个比较重要，代表了索引的思想，值得仔细品味一下，数组+链表的思想</span><br><span class="line">         */</span><br><span class="line">        SkipNode&lt;E&gt;[] next;</span><br><span class="line"></span><br><span class="line">        public SkipNode(int MAX_LEVEL, E val) &#123;</span><br><span class="line">            this.next = new SkipNode[MAX_LEVEL];</span><br><span class="line">            this.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后就是如何建立跳表的过程， 要做到用时比较爽的链表那必然在建立的时候就比普通的插入要复杂，比如插入的时候，需要维护每层的索引值，删除的时候同理,先来看跳表的数据结构,看代码之前铺一张跳表的真面目<br><img src="https://upload-images.jianshu.io/upload_images/13145731-6999255957ecf297.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="来自于极客时间，借用转载.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MySkipList&lt;E extends  Comparable&lt;? super E&gt;&gt;&#123;</span><br><span class="line">    // skip list has two base data structure to approve it&apos;s curd speed -- linkedlist and hash table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 跳表层数32层： 定义成32层理论上对于2^32-1个元素的查询最优。</span><br><span class="line">     */</span><br><span class="line">    private final int MAX_LEVEL = 32;</span><br><span class="line">    /*</span><br><span class="line">     * 当前跳表的有效层</span><br><span class="line">     */</span><br><span class="line">    private int level = 0;</span><br><span class="line">    /*</span><br><span class="line">     * 跳表的头部节点</span><br><span class="line">     */</span><br><span class="line">    private final SkipNode&lt;E&gt; header = new SkipNode&lt;E&gt;(MAX_LEVEL, null);</span><br><span class="line">    /*</span><br><span class="line">     * 随机数发生器</span><br><span class="line">     */</span><br><span class="line">    private final Random random = new Random();</span><br><span class="line">    /*</span><br><span class="line">     * 随机数边界值</span><br><span class="line">     */</span><br><span class="line">    private final double E = 0.5;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入的逻辑，把插入的逻辑搞清楚了之后其他关于跳表的逻辑就比较显而易见了，那么先从最简单的链表的插入开始，怎么插的？当然是在最后的node 上直接一句<br>lastNode.next = newNode 搞定，那么跳表在链表的基础上多了一索引以维持查找时的o（logn），其次是有了索引之后插入也就变得有顺序了，也就是底层的链表其实是有序的，这也正是redis 有序集合的实现原理，其实最主要的就是理解索引，可以从上面的图片中看出来，1这个node 如果在普通的链表中那么只需要维护一个next 的指针指向下一个值，但是因为有了索引的存在，1 这个node 就不能只维护一个next 了，而是需要维护一群next node，比如第一级索引中的nextNode = “4”， 第二级索引中nextNode=“7” 这样，索引就是这样建立起来的，所以在下觉得本质上跳表的索引靠的是数组天然的下标值可以作为索引的依据，在根据上面的图中假如我要插入一个值为6 的node，需要做哪些操作，然后试着自己写一下代码。（这里小小的插入一下不知道在哪里看的Google的工程师们效率永远能做到955的高效率的原因是他们永远先动脑子再写代码，比如写代码之前会在草稿纸上演算一下，理清楚所有逻辑之后才开始撸，这个在学习数据结构和算法甚至是业务代码都需要我保持良好风格）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void insert(E val)&#123;</span><br><span class="line">        SkipNode cur = header;</span><br><span class="line">        SkipNode[] preNodes;</span><br><span class="line">        // 每次写这个循环的时候都觉得很妙，下一次的循环正巧是从索引值往下寻找的,找到每一层的前继node</span><br><span class="line">        for(int i = level; i &gt;= 0 ; --i)&#123;</span><br><span class="line">              // 从第i级索引开始记录需要插入的前继节点,查找的思想是：找到每一层的第一个大于当前代插入的节点的值</span><br><span class="line">              while(cur.next[i] != null &amp;&amp; cur.next[i].compareTo(val) &lt; 0)&#123; </span><br><span class="line">                    cur = cur.next[i];</span><br><span class="line">              &#125;</span><br><span class="line">              preNodes[i] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        // 插入每一层的node 位置的时候，通过一个随机函数值来决定插入的高度和索引，这样做的目的是为了防止插入的效率退化成o（n）,是一个动态更新索引层次的方式</span><br><span class="line">      int  randomLevel  = randomLevel();</span><br><span class="line">      cur = cur.next[0]; </span><br><span class="line">      if(cur == null &amp;&amp; !cur.val.equals(val))&#123; // 当底层的为空，并且不是等于要插入的节点值的时候才有插入的必要</span><br><span class="line">      if(randomLevel &gt; level)&#123; // 上天选择要新加一层索引，那么就需要动态更新level 的值</span><br><span class="line">            preNodes[randomLevel] = header; // 从这里随机加索引可以看出</span><br><span class="line">            level  = randomLevel; </span><br><span class="line">      &#125;</span><br><span class="line">      // 这里才是真正的插入操作，前面全是各种铺垫</span><br><span class="line">      SkipNode&lt;E&gt; insertedNode = new SkipNode(MAX_LEVEL , val);</span><br><span class="line">      for(int i = level; i &gt;= 0; --i)&#123;</span><br><span class="line">          insertedNode.next[i] = preNodes[i].next[i];</span><br><span class="line">          preNodes[i].next[i] = insertedNode;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上跳表的插入就完成了，可见关键做了三个操作：1. 找到每一层的前继节点，维护到数组中，以便后面的真正插入，也是维护索引  2. 动态更新索引，索引的值和层次，层次通过随机函数来维护，随机性可以防止索引退化成为直线链表  3. 真正的每一层的插入操作，可以看出保证有序的链表插入的时间复杂度可以通过上面关键的循环，也就是索引数组的维护由以前的普通的o(n) 变成 o(logn) 的时间复杂度，下面是随机函数生成随机索引值<br>可以看下面的图的逻辑<br><img src="https://upload-images.jianshu.io/upload_images/13145731-3f040036dd808689.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="🙏极客时间"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 利用随机数发生器来决定是否新增一层</span><br><span class="line"> * 通过与E的大小判断，这样可以让平均的概率达到50%,基本上level 也就是平均二叉的level ，当然也可以调节E的大小，也就是概率大小调节高度的</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private int randomLevel() &#123;</span><br><span class="line">    double ins = random.nextDouble();</span><br><span class="line">    int nextLevel = level;</span><br><span class="line">    if (ins &gt; E &amp;&amp; level &lt; MAX_LEVEL) &#123; // 一切交给命运的随机nextLevel</span><br><span class="line">        nextLevel++;</span><br><span class="line">    &#125;</span><br><span class="line">    return nextLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delete 的操作同理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void delete(E val) &#123;</span><br><span class="line">        SkipNode&lt;E&gt; cur = Header;</span><br><span class="line">        SkipNode&lt;E&gt;[] predecessors = new SkipNode[MAX_LEVEL];</span><br><span class="line">        /*</span><br><span class="line">         * 寻找待删除元素在不同层上的前继节点</span><br><span class="line">         */</span><br><span class="line">        for (int i = level; i &gt;= 0; i--) &#123;</span><br><span class="line">            while (cur.next[i] != null &amp;&amp; cur.next[i].val.compareTo(val) &lt; 0) &#123;</span><br><span class="line">                cur = cur.next[i];</span><br><span class="line">            &#125;</span><br><span class="line">            predecessors[i] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next[0];</span><br><span class="line">        /*</span><br><span class="line">         * 跳表中不含此节点</span><br><span class="line">         */</span><br><span class="line">        if (cur != null &amp;&amp; !cur.val.equals(val)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt;= level; i++) &#123;</span><br><span class="line">            if (predecessors[i].next[i] != null )&#123;</span><br><span class="line">                if (!predecessors[i].next[i].val.equals(val)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessors[i].next[i] =  predecessors[i].next[i].next[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * 如果删除元素val后level层元素数目为0，层数减少一层</span><br><span class="line">         */</span><br><span class="line">        while (level &gt; 0 &amp;&amp; header.next[level] == null) &#123;</span><br><span class="line">            level--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的操作需要几点注意的地方，不然就要NPE 的错误，在任何直接有判断xxxNode.next[i].xxx 的语句情况下都要判断xxxNode.next[i] assert null ? 的操作，这个算是链表的常见错误，其次是最后的level 的判断是否要减少<br>完整的可以见我的github 账号<a href="https://github.com/amorynan/study" target="_blank" rel="noopener">https://github.com/amorynan/study</a><br> 欢迎留言<br>最后再来看一下空间复杂度的情况，不能只看好处不看坏处嘛，空间复杂度当然是随着时间复杂度的下降而上升的，所以当你的随机函数调节的高度接近二叉的的话，那么可以依次算出第一层索引需要n/2 个nodes，第二层索引需要n/4 个nodes ，一直到最后一层以2的倍数递减，所以总的空间复杂度就是n，如果是接近三叉的话，那总的空间复杂度就是n/2 ，其实这个值是直接和递减的倍数相关的，有兴趣的可以推导一下.</p>
</div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/跳表/">跳表</a><a class="post-meta__tags" href="/tags/算法/">算法</a><a class="post-meta__tags" href="/tags/数据结构/">数据结构</a><a class="post-meta__tags" href="/tags/skipLinkedList/">skipLinkedList</a></div></article><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/06/23/数组linkedlist实现/"><i class="fa fa-chevron-left">  </i><span>数组和链表+以及java 容器的实现</span></a></div><div class="next-post pull-right"><a href="/2019/05/30/my-first-blog-test/"><span>my first blog test</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment_title" class="gitment_title"></div>
<div id="container" style="display:none"></div>
<link rel="stylesheet" href="https://www.wenjunjiang.win/css/gitment.css">
<script src="https://www.wenjunjiang.win/js/gitment.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
<script>
  const myTheme = {
    render(state, instance) {
      const container = document.createElement('div');
      container.lang = "en-US";
      container.className = 'gitment-container gitment-root-container';
      container.appendChild(instance.renderHeader(state, instance));
      container.appendChild(instance.renderEditor(state, instance));
      container.appendChild(instance.renderComments(state, instance));
      container.appendChild(instance.renderFooter(state, instance));
      return container;
    }
  }

  function showGitment() {
    $("#gitment_title").attr("style", "display:none");
    $("#container").attr("style", "").addClass("gitment_container");
    var gitment = new Gitment({
      id: decodeURI(window.location.pathname),
      theme: myTheme,
      owner: 'amorynan',
      repo: 'https://amorynan.github.io/',
      oauth: {
        client_id: 'dd00b7cc5fbce0060c2d',
        client_secret: '9e044107808ba825bdf0990c19c4501de74bdcec'
      }
    });
    gitment.render('container');
  }

  showGitment();
</script>
</div></div><footer><div class="layout" id="footer"><div class="copyright">©2013 - 2019 By amory wang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span> |  </span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/fancybox.js"></script><script src="/js/sidebar.js"></script><script src="/js/copy.js"></script><script src="/js/fireworks.js"></script><script src="/js/transition.js"></script><script src="/js/scroll.js"></script><script src="/js/head.js"></script></body></html>